package Lesson_46;

import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

// Queue -  интерфейс Очередь
public class QueueMain {

    /*
    Очередь - это структура данных, которая работает по принципу "первым пришёл, первым вышел"
    (FIFO - First-In-First-Out). Это означает, что элементы, добавленные в очередь раньше,
    будут удалены из нее раньше всех.

    Очередь можно реализовать через LinkedList или PriorityQueue
     */
    public static void main(String[] args) {


        Queue<String> queue = new LinkedList<>();

//        добавить элементы
        /*
        Добавление элемента: add(E e) или offer(E e). Оба метода добавляют элемент в очередь.
         Разница в поведении при полной очереди: add генерирует исключение, а offer возвращает false.
         */
        queue.add("John");
        queue.add("Jack");
        queue.add("Ann");
        queue.add("Mary");

        queue.offer("Jim");
        System.out.println(queue); // [John, Jack, Ann, Mary]  элементы бобавляються в конец очереди
//        *******************
//        удалить элементы
        /*
        Удаление элемента: remove() или poll(). Оба метода удаляют и возвращают элемент из головы очереди.
        Разница в поведении при пустой очереди: remove генерирует исключение, а poll возвращает null.
         */
        System.out.println(queue.remove());//  если не говорить кого удалить из очереди - удалит по умолчанию
        // первый элемент // John

        System.out.println(queue.poll()); // Jack

//        ***********************
        /*
        Просмотр элемента: element() или peek(). Оба метода возвращают элемент из головы очереди, но не удаляют его.
         Разница в поведении при пустой очереди: element генерирует исключение, а peek возвращает null.

         peek() - возвращает элемент из начала очереди не удаляя его
         poll() - возвращает элемент из начала очереди удаляя!!! его

         */
//***********************************************
        /*
        PriorityQueue - это реализация очереди с приоритетом в Java. Эта структура данных позволяет хранить элементы и
        извлекать их на основе их приоритета. Важно отметить, что в PriorityQueue элементы извлекаются не в том порядке,
        в котором они были добавлены, а в порядке возрастания или убывания приоритета.

        Ключевые особенности PriorityQueue:

         Приоритетность: Элементы в PriorityQueue хранятся в порядке их приоритета.
         Элементы с более высоким приоритетом извлекаются раньше элементов с более низким приоритетом.

         Реализация: PriorityQueue может быть реализована как мин-куча (наименьший элемент на вершине) или макс-
         В Java по умолчанию реализуется мин-куча, но вы можете изменить ее на макс-кучу, указав компаратор при создании.

         Динамический размер: PriorityQueue может динамически увеличивать свой размер по мере необходимости.

         Быстрое извлечение наивысшего приоритета: Извлечение элемента с наивысшим приоритетом выполняется за
         время O(log n), где n - количество элементов в очереди.

         Нет гарантированного порядка: PriorityQueue не гарантирует порядок элементов, если их приоритеты одинаковы.
         Если вам нужен порядок вставки, вы должны дополнительно хранить информацию о времени добавления.

         */
        // PriorityQueue -  использует Comparator  для того, чтобы задать способ сортировки
        // ( расположения элементов в очереди)
        PriorityQueue<String> names = new PriorityQueue<>(new  PriorityComparator());
        names.add("kiwi");
        names.add("lemon");
        names.add("banana");
        names.add("watermelon");
        /*
        PriorityComparator - задали сортировку от меньшего к большему
        @Override
    public int compare(String o1, String o2) {
        return o1.length() - o2.length();

        В данном случае, метод compare сравнивает строки на основе их длины.
        Когда o1.length() (длина первой строки) больше чем o2.length() (длина второй строки),
        метод вернет положительное число. Если o1.length() меньше чем o2.length(), то метод вернет отрицательное число.
        Если длины строк равны, то метод вернет ноль.
    }
         */

        while (names.size()!=0){
            System.out.println(names.poll());
        }


        /*
        kiwi
        lemon
        banana
        watermelon

         */



    }
}
